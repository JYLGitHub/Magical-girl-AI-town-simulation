# AI Town 완전 분석 및 구현 가이드

## 목차
1. [AI Town 아키텍처 개요](#ai-town-아키텍처-개요)
2. [핵심 구성 요소 상세 분석](#핵심-구성-요소-상세-분석)
3. [단계별 구현 로드맵](#단계별-구현-로드맵)

---

## AI Town 아키텍처 개요

### 전체 아키텍처: 연극의 구성 요소

AI Town은 하나의 연극에 비유할 수 있습니다. 각 구성 요소는 연극의 스태프와 배우처럼 명확한 역할을 가집니다.

- **서버 측 게임 로직 (`convex/aiTown`)**: 연극의 **대본**입니다. 캐릭터(플레이어)의 상태, 규칙, 상호작용의 결과를 정의합니다.
- **클라이언트 측 게임 UI (`src/`)**: 연극의 **무대**입니다. 서버에서 계산된 모든 게임 상태를 사용자(관객)에게 시각적으로 보여주는 역할을 합니다.
- **게임 엔진 (`convex/engine`)**: 연극의 **총감독**입니다. 대본(게임 로직)에 따라 시간을 흐르게 하고, 배우(에이전트)의 연기를 조율하며, 전체 흐름을 관리합니다.
- **에이전트 (`convex/agent`)**: 연극의 **AI 배우**입니다. 대본을 기반으로 스스로 판단하고 연기하며 다른 배우와 상호작용합니다.

---

## 핵심 구성 요소 상세 분석

### 1. AI의 뇌와 심장: 에이전트 아키텍처 (`convex/agent`)

AI가 어떻게 생각하고, 기억하며, 행동하는지에 대한 모든 로직이 여기에 담겨 있습니다.

#### AI의 행동 흐름: 에이전트 루프 (Agent Loop)

AI는 매 순간 복잡한 생각을 하는 것이 아니라, 정해진 루프에 따라 '보고, 생각하고, 행동'합니다. 이 과정은 주로 **`convex/aiTown/agent.ts`** 파일의 **`Agent`** 클래스, 특히 **`tick()`** 함수에서 시작됩니다.

**1. 관찰 및 판단 (Agent.tick)**
- **언제?** 매 스텝(Step, 1초)마다 `Agent.tick()` 함수가 실행됩니다.
- **무엇을?** 주변 상황을 관찰합니다. "주변에 누가 있는가?", "진행 중인 작업이 있는가?", "누군가 나를 대화에 초대했는가?" 등의 게임 상태 변화를 감지합니다.
- **판단:** 복잡한 LLM 호출 없이, 미리 정해진 규칙(Rule-based)에 따라 간단한 판단을 내립니다.
  - 이미 진행 중인 작업(`inProgressOperation`)이 있다면, 끝날 때까지 기다립니다.
  - 대화에 초대받으면, 상대가 인간이면 무조건 수락하고, AI면 설정된 확률(`INVITE_ACCEPT_PROBABILITY`)에 따라 수락 여부를 결정합니다.
  - 대화가 시작되었는데 아무도 말을 안 하면, 설정된 시간(`AWKWARD_CONVERSATION_TIMEOUT`)이 지났을 때 먼저 말을 겁니다.

**2. "생각" 시작 (startOperation)**
- **언제?** 관찰과 판단을 통해 "이제 행동해야겠다!" (예: '저 플레이어에게 말을 걸어야겠다')라는 결론에 도달하면 `startOperation`을 호출합니다.
- **무엇을?** 대화 내용 생성, 기억 저장 등 **시간이 오래 걸리는 비동기 작업(주로 `internalAction`)을 시작하라는 신호**입니다. 이는 게임의 메인 흐름(tick)에 영향을 주지 않고 독립적으로 진행됩니다.

**3. 깊은 생각과 외부 소통 (LLM 호출)**
- **어디서?** `convex/agent` 폴더 내의 다양한 파일들, 특히 **`conversation.ts`** (대화 생성)와 **`memory.ts`** (기억 처리)에서 실제 LLM API와의 통신이 이루어집니다.
- **어떻게?** 정교하게 구성된 **프롬프트(Prompt)**를 LLM에 전달합니다. 프롬프트에는 다음과 같은 정보가 모두 포함됩니다:
  - **기본 정보**: "너는 [AI 이름]이고, [상대방 이름]과 대화 중이야."
  - **자신에 대한 정보**: "나는 활기차고 사람들과 어울리는 것을 좋아하는 성격이야."
  - **대화 목표**: "오늘 대화에서는 상대방의 취미에 대해 알아보고 싶어."
  - **관련 기억**: "며칠 전 앨리스와 정원에서 꽃에 대해 이야기했다."
  - **대화 기록**: 현재까지의 대화 내용 전체

**4. 행동 결정 및 실행 요청 (Input 제출)**
- **무엇을?** "생각"이 끝나고 "안녕, 오늘 날씨 좋네!"와 같은 구체적인 행동 내용이 정해지면, AI는 이 행동을 게임 세계에 반영해달라고 **'입력(Input)'을 시스템에 제출**합니다.
- **어떻게?** AI는 게임 상태를 직접 수정하지 않습니다. 대신 "이 메시지를 채팅창에 띄워줘" 또는 "저쪽으로 걸어가줘" 와 같은 요청을 게임 엔진에 보냅니다. 이는 사람 플레이어가 키보드를 누르는 것과 동일한 방식으로 처리됩니다.

**5. 상태 업데이트 및 마무리**
- 요청한 행동이 게임 세계에 반영되면, AI는 진행 중이던 "생각"(`inProgressOperation`)을 완료 처리(삭제)합니다. 이는 AI가 **한 번에 하나의 복잡한 작업만 수행하도록 보장**하여 행동이 꼬이는 것을 막는 중요한 장치입니다.

#### AI의 기억 메커니즘 (`convex/agent/memory.ts`)

AI가 과거를 기억하고 관계를 쌓는 핵심 시스템입니다. 단순 저장이 아닌, **'요약 → 평가 → 변환 → 저장 → 검색 → 활용'**의 정교한 과정을 거칩니다.

**1. 요약 및 평가 (`rememberConversation`)**
- 대화가 끝나면, LLM에게 "방금 나눈 대화를 1인칭 시점으로 요약해줘"라고 요청하여 대화 내용을 압축합니다.
- 그 다음, 요약된 내용을 바탕으로 또 다른 LLM을 호출하여 "이 기억이 얼마나 중요한지 0점에서 9점 사이로 점수를 매겨줘"라고 요청해 **'기억의 중요도'** 점수를 얻습니다.

**2. 벡터 변환 및 저장 (`fetchEmbedding` & `insertMemory`)**
- '중요도'가 매겨진 요약문은 **임베딩(Embedding)** 기술을 통해 AI가 이해할 수 있는 숫자의 배열, 즉 **벡터(Vector)**로 변환됩니다. 텍스트의 '의미'를 좌표 값으로 바꾸는 과정입니다.
- **`embeddingsCache.ts`**: 동일한 텍스트에 대한 임베딩을 반복적으로 계산하는 것을 피하기 위해, 결과를 캐시(임시 저장)하여 비용을 절약합니다.
- 최종적으로 이 기억 벡터, 중요도 점수, 요약 텍스트 등이 데이터베이스의 **`memories` 테이블**에 저장됩니다.

**3. 기억 검색 및 랭킹 (`searchMemories`)**
- AI가 새로운 행동(예: 대화 시작)을 할 때, 현재 상황(예: "앨리스와 대화 시작")을 벡터로 변환합니다.
- 이 벡터와 데이터베이스에 저장된 모든 기억 벡터들의 **'의미적 유사도'**를 비교하여, 가장 관련성이 높은 기억들을 여러 개 찾아냅니다.
- 찾아낸 기억들은 3가지 기준으로 최종 순위가 매겨집니다:
  - **관련성 (Relevance)**: 현재 상황과 얼마나 의미가 비슷한가?
  - **중요도 (Importance)**: 과거에 저장했던 중요도 점수가 얼마나 높은가?
  - **최신성 (Recency)**: 얼마나 최근에 있었던 일인가?
- 이렇게 종합 점수가 가장 높은 상위 3개의 기억만이 최종적으로 AI의 "단기 기억"으로 선택되어 프롬프트에 주입됩니다.

**4. 성찰 (`reflectOnMemories`)**
- AI는 단순히 기억을 쌓기만 하는 게 아니라, 때때로 "성찰"을 통해 더 높은 수준의 통찰을 얻습니다.
- 최근 100개 기억의 '중요도' 점수 합계가 특정 기준(500점)을 넘으면 성찰 과정이 시작됩니다. 중요한 사건이 많았다는 뜻입니다.
- LLM에게 최근 기억 목록을 보여주며 "이 진술들로부터 추론할 수 있는 3가지 고차원적인 통찰은 무엇이니?"라고 질문합니다.
- "나는 사람들과 기술에 대해 이야기하는 것을 즐긴다"와 같은 통찰이 생성되면, 이 또한 하나의 새로운 '성찰 기억'으로 데이터베이스에 저장되어 AI의 정체성 형성에 기여합니다.

### 2. 세상의 규칙과 시간: 게임 엔진 (`convex/engine`)

AI와 인간 플레이어가 활동하는 세상의 물리 법칙과 시간의 흐름을 관장하는 총감독입니다.

#### 시간 관리: 틱(Tick)과 스텝(Step)

AI Town의 시간은 두 가지 단위로 관리되어, 효율성과 현실감을 모두 잡습니다.

- **틱 (Tick)**: 게임 세계의 가장 작은 시간 단위로, 1초에 60번 발생합니다. 캐릭터의 부드러운 움직임 계산처럼 **시각적이고 즉각적인 처리**를 담당합니다. 틱마다 데이터베이스에 접근하지는 않습니다.
- **스텝 (Step)**: 여러 틱(AI Town에서는 60개)을 하나로 묶은 단위로, **1초에 단 한 번 실행**됩니다. AI의 의사결정, 데이터베이스 저장 등 **무겁고 중요한 작업**들은 바로 이 스텝 단위로 모아서 처리됩니다.

#### 입력 처리 (Input Processing)

플레이어(AI, 인간)가 세상에 영향을 미치는 모든 행동은 '입력(Input)'이라는 절차를 통해 처리됩니다.

1. 플레이어가 행동을 하면(예: `moveTo` 입력), 이 요청은 데이터베이스의 **`inputs` 테이블**에 저장됩니다.
2. 게임 엔진은 이 테이블에 저장된 순서대로 입력을 하나씩 처리하고, 그 결과를 다시 테이블에 기록합니다.
3. 클라이언트(사용자 화면)는 이 테이블의 변경 사항을 실시간으로 감지하여 입력 처리 상태를 확인할 수 있습니다.

#### 시뮬레이션 실행 및 상태 관리

엔진은 '싱글 스레드' 방식으로 작동하여, 동시에 여러 스텝이 실행되는 것을 방지하고 코드의 복잡성을 낮춥니다. 스텝 실행 과정은 다음과 같습니다:

1. 스케줄러가 `runStep` 액션을 호출합니다.
2. `loadWorld` 쿼리를 통해 현재 게임 상태 전체를 데이터베이스에서 메모리로 불러옵니다.
3. 불러온 데이터를 기반으로 `Game` 객체를 생성하고, 시뮬레이션을 실행하여 **메모리상의 게임 객체**를 수정합니다.
4. 스텝이 끝나면 `saveStep`을 호출하여 **변경이 일어난 부분만** 데이터베이스에 다시 저장하여 효율을 높입니다.

#### '순간이동' 방지: 히스토리 테이블

서버는 1초(1 스텝)에 한 번만 위치를 업데이트하지만, 우리 눈에는 캐릭터가 부드럽게 걸어가는 것처럼 보입니다.

- 이는 서버가 1초 동안의 모든 '틱'에서의 위치 변화를 하나의 압축된 데이터 묶음('히스토리')으로 저장하기 때문입니다.
- 클라이언트는 이 히스토리 데이터를 받아서 1초 동안의 움직임을 자체적으로 '재생'합니다. 덕분에 서버와 통신하는 횟수는 적지만, 사용자에게는 매끄러운 움직임을 보여줄 수 있습니다.

### 3. 세상의 설계도: 데이터 모델 및 로직 (`convex/aiTown`)

게임 세계를 구성하는 핵심 요소들과 그 관계를 정의하는 부분입니다.

**데이터 모델:**
- **Worlds**: 여러 플레이어가 함께 상호작용하는 게임 맵
- **Players**: 게임의 핵심 캐릭터 (인간 또는 AI). 이름, 설명, 위치, 이동 경로 등의 정보를 가집니다.
- **Conversations**: 플레이어 간의 상호작용
- **Conversation Memberships**: 플레이어가 대화에 참여 중임을 나타냅니다. 멤버십 상태는 `초대됨(invited)`, `걸어가는 중(walkingOver)`, `참여 중(participating)` 세 가지로 나뉩니다.

**스키마 (Schema)**: 데이터가 저장되는 방식을 정의하는 '설계도'입니다. 엔진, 게임, 에이전트 테이블로 나뉩니다.

**입력 (Inputs)**: 플레이어가 게임 세계에 영향을 미치는 행동들입니다. `join`, `leave`, `moveTo`, `startConversation` 등이 있으며, 각 입력은 정해진 규칙에 따라 게임 상태를 변경합니다.

**메시지 데이터 모델**: 채팅 메시지는 핵심 게임 엔진과 별도의 테이블에서 관리됩니다. 메시지는 매우 자주 업데이트되므로, 엔진을 거치지 않고 직접 처리하는 것이 더 빠르고 효율적이기 때문입니다.

### 4. 세상의 창문: 클라이언트 UI (`src/`)

서버에서 일어나는 모든 일을 사용자에게 보여주는 화면 부분입니다.

- **`useQuery`**: Convex(백엔드)의 표준 훅을 사용하여 테이블의 게임 상태 데이터를 실시간으로 불러와 UI에 렌더링합니다.
- **`useHistoricalValue`**: '히스토리 테이블'의 데이터를 사용하기 위한 특별한 훅입니다. 시간에 따라 값이 부드럽게 변하는 것처럼 보여주는 역할을 합니다.
- **`useSendInput`**: 서버에 '입력(Input)'을 보내고 처리 결과를 기다리는 과정을 쉽게 구현할 수 있도록 돕는 훅입니다.

---

## 단계별 구현 로드맵

### Phase 0: 프로젝트 기반 설계 (Foundation & Architecture)

**목표:** 단순한 폴더 생성을 넘어, AI Town의 핵심 설계 철학인 **'역할의 분리'**를 이해하고 프로젝트 구조에 반영합니다.

**AI Town의 철학:** AI Town은 게임 엔진과 게임 로직, 그리고 AI 에이전트의 행동을 명확하게 분리했습니다. 이는 사람 플레이어와 AI 에이전트가 동일한 규칙(입력 시스템)을 통해 세상에 영향을 미치도록 하여 코드의 유지보수성과 확장성을 높입니다.

**프로젝트 구조:**
```
/ai-simulation
|-- index.html         // UI (무대)
|-- /js
|   |-- main.js        // 모든 모듈을 총괄하는 관제탑
|   |-- engine.js      // 게임 엔진 (총감독)
|   |-- gameLogic.js   // 게임 로직 (대본)
|   |-- agent.js       // AI 에이전트 (배우)
|   |-- ui.js          // UI 렌더링 담당
|
|-- /data
|   |-- world.json     // 세상의 상태 정보
|   |-- characters.json// 캐릭터의 상태 정보
```

**핵심 데이터 객체 `gameState`**: `main.js`에서 시뮬레이션의 모든 상태를 담을 중앙 객체를 정의합니다. 이 객체는 AI Town의 데이터베이스 테이블들을 단순화한 버전입니다.

```javascript
let gameState = {
  turn: 0,
  world: { ... }, // world.json 데이터
  characters: { ... }, // characters.json 데이터 (객체 형식으로 변경, ID를 key로 사용)
  conversations: {}, // 현재 진행중인 모든 대화 상태
  inputs: [], // 처리해야 할 입력 목록
  log: []
};
```

### Phase 1: 시간의 흐름과 세상의 규칙 (Engine & Time)

**목표:** AI Town의 핵심 시간 개념인 **틱(Tick)과 스텝(Step)**을 구현하여 시뮬레이션의 심장 박동을 만듭니다.

**AI Town의 시간 관리:** AI Town은 1초에 60번의 **틱(Tick)**과 1초에 1번의 **스텝(Step)**으로 시간을 관리합니다. 틱은 부드러운 움직임 같은 시각적 처리를, 스텝은 AI의 판단이나 DB 저장 같은 무거운 작업을 담당합니다. 우리는 '다음 턴 진행' 버튼 클릭을 **1 스텝**으로 간주하고 시뮬레이션을 진행합니다.

**구현 방법 (`engine.js`):**

1. **`engine.runStep(gameState)` 함수 (총감독의 역할):** 이 함수가 한 턴(스텝)을 진행시키는 핵심입니다.
   - **입력 처리:** `gameState.inputs` 배열에 쌓인 요청들을 순서대로 처리합니다. 각 `input`에 맞는 `gameLogic.js`의 함수를 호출하여 `gameState`를 변경합니다.
   - **AI 틱 실행:** 모든 `character`에 대해 `agent.tick(character, gameState)` 함수를 호출하여 각 AI가 '관찰하고 판단'하게 합니다.
   - **시간 경과 처리:** `gameState.turn`을 1 증가시키고, 게임 세계의 자체적인 변화(예: 욕구 감소)를 처리합니다.

2. **`agent.js`에 `startConversation` 함수 구현 (깊은 생각):**
   - `async` 함수로 만듭니다.
   - 대화를 위한 프롬프트를 생성합니다 (Phase 2의 프롬프트와 유사).
   - `await fetch(...)`를 사용해 LLM API를 호출합니다.
   - **행동 요청:** LLM에게 받은 대답으로 '대화 메시지 전송' 입력을 만들어 `gameState.inputs`에 추가합니다.
   - **마무리:** `character.inProgressOperation`을 `null`로 바꿔 작업이 끝났음을 표시합니다.

3. **`gameLogic.js`**에 대화 시작(`createConversation`), 메시지 전송(`sendMessage`) 등의 규칙을 추가하여 `gameState`를 업데이트하도록 합니다.

### Phase 4: 정교한 기억 시스템 (Memory & Reflection)

**목표:** AI Town의 핵심인 **벡터 기반 기억 및 성찰 시스템**을 구현합니다.

**AI Town의 기억 시스템 (`convex/agent/memory.ts`):** 대화가 끝나면 **요약 → 중요도 평가 → 벡터 변환 → 저장** 과정을 거치고, 대화를 시작할 때는 **검색 → 랭킹 → 활용** 과정을 통해 가장 관련 있는 기억을 꺼내옵니다.

**구현 방법:**

1. **기억 저장 (`agent.rememberConversation`):**
   - 대화가 끝나면 이 `async` 함수를 호출합니다.
   - **1차 LLM 호출:** 대화 내용을 1인칭으로 요약합니다.
   - **2차 LLM 호출:** 요약문을 바탕으로 0~9점의 '중요도' 점수를 부여받습니다.
   - **(선택) 3차 API 호출:** 요약문을 임베딩 API로 보내 벡터로 변환합니다. (API가 없다면 이 단계는 생략하고 텍스트 매칭으로 대체)
   - `character.memory.logs`에 {요약문, 중요도, 벡터, ...} 객체를 저장합니다.

2. **기억 검색 (`agent.searchMemories`):**
   - 대화를 시작하기 전(`startConversation` 내부에서) 이 함수를 호출합니다.
   - 현재 상황(예: "앨리스와 대화 시작")을 벡터로 변환합니다.
   - 모든 기억 로그를 순회하며 저장된 벡터와 유사도를 계산합니다.
   - AI Town처럼 **관련성(유사도), 중요도, 최신성**을 종합하여 최종 점수를 매기고, 가장 점수가 높은 기억 3개를 반환합니다.

3. **성찰 (`agent.reflect`):**
   - `engine.runStep`에서 특정 조건(예: 20턴마다 또는 중요도 합계가 임계값을 넘을 때)이 되면 이 `async` 함수를 호출합니다.
   - 최근 기억 목록을 LLM에게 보내 "3가지 고차원적인 통찰"을 생성하도록 요청합니다.
   - 생성된 통찰을 높은 중요도 점수와 함께 새로운 '성찰 기억'으로 저장합니다.

### Phase 5: 유기적인 사회 시스템 (Advanced Socials & World)

**목표:** 위에서 구축한 정교한 AI 에이전트 시스템을 기반으로, 단체 대화, 소문 확산 등 복잡한 사회적 현상을 구현합니다.

**AI Town의 확장성:** 잘 분리된 아키텍처 덕분에 새로운 사회적 규칙을 추가하기 용이합니다. 모든 것은 **`Agent.tick`의 관찰/판단 능력**과 **`gameLogic`의 규칙**을 확장하는 것으로 귀결됩니다.

**구현 방법:**

1. **단체 대화:**
   - **`gameLogic`:** `gameState.conversations` 객체가 여러 명의 `participants`를 가질 수 있도록 수정합니다.
   - **`agent.tick`:** AI는 이제 주변에 '사람'이 아닌 '진행 중인 대화'가 있는지도 관찰해야 합니다.
   - **`agent`의 "생각":** LLM 프롬프트에 모든 대화 참여자와 전체 대화 로그를 포함시키고, 누구에게 말할지(`target`)를 명시적으로 결정하도록 요청합니다.

2. **주관적 관계 정의:**
   - `character.relationships` 객체에 상대방에 대한 다각적인 평가(신뢰도, 존경심, 의심 등)를 저장합니다.
   - `agent.rememberConversation`에서 대화 요약 후 LLM에게 이 관계 점수들을 업데이트하도록 요청합니다.
   - 모든 프롬프트에 이 주관적인 관계 요약(`summary`)을 포함시켜 AI의 태도에 영향을 줍니다.

3. **욕구 시스템:**
   - `character.needs` 객체(energy, social 등)를 추가합니다.
   - `engine.runStep`에서 매 턴마다 욕구 수치를 조금씩 감소시킵니다.
   - `agent.tick` 함수의 **가장 첫 부분**에서 욕구 수치를 확인하고, 임계값보다 낮으면 다른 모든 행동을 중단하고 욕구 해결 행동(예: 휴식, 대화 상대 찾기)을 최우선으로 하도록 '입력'을 제출합니다.

### Phase 6: 세계관 덧입히기 (Foundation & Character Setup)

**목표:** 기본적인 세상과 캐릭터 데이터를 불러와 웹페이지에 표시합니다. 시뮬레이션의 무대와 배우를 준비하는 단계입니다.

**시스템 설계 및 데이터 구조:**

**`data/characters.json`**: 모든 캐릭터의 기본 정보를 담는 배열입니다.
```json
[
  {
    "id": "char1",
    "name": "앨리스",
    "description": "활기차고 호기심 많은 소녀.",
    "location": "town_square",
    "color": "#e07a5f"
  },
  {
    "id": "char2",
    "name": "밥",
    "description": "조용하고 책 읽기를 좋아하는 소년.",
    "location": "library",
    "color": "#81b29a"
  }
]
```

**`data/world.json`**: 세상의 장소 정보를 담는 객체입니다.
```json
{
  "locations": {
    "town_square": { "name": "마을 광장", "description": "사람들이 모이는 활기찬 곳." },
    "library": { "name": "도서관", "description": "조용한 지식의 전당." }
  }
}
```

**구현 방법:**

1. **`main.js`**: `window.onload` 이벤트나 DOMContentLoaded 이벤트를 사용하여, 페이지 로딩 시 `fetch`로 두 JSON 파일을 비동기적으로 불러옵니다.
2. 불러온 데이터를 `gameState.characters`와 `gameState.world`에 저장합니다.
3. 데이터 로딩이 완료되면 `ui.js`에 있는 `renderAll(gameState)` 함수를 호출합니다.
4. **`ui.js`**: `renderAll(gameState)` 함수를 만듭니다. 이 함수는 `characters-container` div의 내용을 비우고, `gameState.characters` 배열을 순회하며 각 캐릭터의 정보를 표시하는 새로운 `<div>`를 만들어 추가합니다.

### Phase 7: 첫 번째 자율 행동 (Simple Action)

**목표:** AI가 LLM 없이, 간단한 규칙(Rule-based)에 따라 스스로 판단하여 다른 장소로 이동하게 만듭니다.

**구현 방법:**

1. **`ai.js`**의 `thinkAndAct` 함수를 구체화합니다.
   - **의사결정**: `Math.random()`을 사용해 50% 확률로 '이동'을 결정하게 합니다.
   - **행동 실행**: 이동하기로 결정했다면, `gameState.world.locations` 목록에서 현재 위치가 아닌 다른 장소를 무작위로 하나 골라 `character.location` 값을 변경합니다.
   - **로그 기록**: 로그 메시지를 생성하여 `gameState.log` 배열의 맨 앞에 추가합니다.

2. **`ui.js`**의 `renderAll` 함수를 수정합니다.
   - `log-container` div의 내용을 비우고, `gameState.log` 배열의 내용을 순서대로 `<p>` 태그로 만들어 표시하도록 기능을 추가합니다.

### Phase 8: 첫 번째 대화와 단기 기억 (LLM Integration)

**목표:** 같은 장소에 있는 AI들이 서로 대화를 시작하게 하고, 방금 한 대화 내용을 다음 턴에 기억하게 만듭니다.

**시스템 설계 및 데이터 구조:**

**`characters.json`**: 각 캐릭터 객체에 단기 기억을 저장할 필드를 추가합니다.
```json
"memory": {
  "lastConversationWith": {} // 예: { "char2": "책에 대한 이야기를 나눴다." }
}
```

**구현 방법:**

1. **`ai.js`**의 `thinkAndAct` 함수를 수정합니다.
   - **의사결정 로직 변경**: 무작위 이동 대신, '주변 탐색'을 먼저 하도록 합니다.
   - 현재 위치에 자신 외에 다른 캐릭터가 있는지 찾습니다.
   - **대화 상대 발견 시**: LLM 프롬프트 생성, API 호출, 상태 업데이트, 기억 저장의 과정을 거칩니다.

### Phase 9: 복잡한 사회적 관계망 (Complex Relationships)

**목표:** '존경하지만 수상한 선배'처럼, 단순 호감도를 넘어 주관적이고 입체적인 관계를 AI가 스스로 정의하고 행동에 반영하게 합니다.

**시스템 설계 및 데이터 구조:**

**`characters.json`**: 각 캐릭터 객체에 관계 정보를 저장할 `relationships` 객체를 추가합니다.
```json
"relationships": {
  "char2": {
    "affinity": 65,     // 전반적인 호감도
    "respect": 20,      // 존경심
    "trust": 70,        // 신뢰도
    "suspicion": 10,    // 의심
    "summary": "함께 있으면 편안하고 믿을 수 있는 좋은 친구."
  }
}
```

**구현 방법:**

1. **관계 업데이트 로직 추가**
2. **모든 프롬프트에 관계 정보 주입**
3. **비대칭 관계의 자연스러운 구현**

### Phase 10: 내면의 목소리 (Needs & Motivation)

**목표:** AI가 배고픔, 피곤함, 외로움(사교 욕구) 등을 느끼고, 이를 해소하기 위해 스스로 행동하게 만들어 행동의 근본적인 동기를 부여합니다.

**시스템 설계 및 데이터 구조:**

**`characters.json`**: 각 캐릭터에게 `needs` 객체를 추가합니다 (100점 만점).
```json
"needs": {
  "energy": 80, // 피로도 (낮을수록 피곤)
  "social": 50  // 사교 욕구 (낮을수록 외로움)
}
```

### Phase 11: 살아 숨 쉬는 사회 (Advanced Dynamics)

**목표:** 단체 대화, 대화 끼어들기, 소문 확산 등 예측 불가능한 사회적 현상이 나타날 수 있는 시스템을 구축합니다.

**시스템 설계 및 데이터 구조:**

**`gameState`**: 대화와 정보를 중앙에서 관리하는 독립적인 객체로 분리합니다.
```javascript
"conversations": {
  "conv1": {
    "participants": ["char1", "char2", "char3"],
    "location": "town_square",
    "log": [ { "speaker": "char1", "target": "all", "message": "..." } ]
  }
},
"informations": {
  "info1": {
    "content": "찰리가 시험에서 부정행위를 했다.",
    "truthfulness": 0.3, // 진실일 확률
    "knownBy": ["char1", "char2"]
  }
}
```

**구현 방법:**

1. **단체 대화**: `startConversation` 함수는 이제 두 캐릭터를 묶는 대신, `gameState.conversations`에 새로운 대화 객체를 생성합니다.
2. **대화 끼어들기/떠나기**: `thinkAndAct`에서 대화 중이 아닐 때, 현재 위치에 진행 중인 대화가 있는지 확인하고 참여를 결정합니다.
3. **소문의 확산**: 대화 중 특정 정보가 나오면, LLM이 이를 '정보'로 인식하고 `gameState.informations`에 등록하도록 합니다.

### Phase 12: 세계관 덧입히기 (Applying Worldview)

위 11단계까지 완성했다면, 당신은 **"스스로의 욕구, 관계, 신념에 따라 행동하고, 과거를 기억하며 살아가는 AI 인간 시뮬레이션 엔진"**을 갖게 된 것입니다. 이제 이 엔진 위에 원하는 세계관을 '스킨'처럼 씌우기만 하면 됩니다.

**마법소녀 세계관:**
- `characters.json`에 `identities` (민간인/마법소녀), `stats` (HP, MP) 필드를 추가합니다.
- '악당' 타입의 AI를 추가하고, 이들의 `thinkAndAct` 로직은 `needs` 대신 '파괴 활동'이라는 고정된 목표를 갖도록 만듭니다.
- '악당 출현' 같은 특정 `event` 시스템을 추가합니다.

**TRPG 세계관:**
- 사용자가 직접 텍스트를 입력할 수 있는 UI와, 그 입력을 처리할 특별한 `GMAgent`를 만듭니다.
- `GMAgent`는 플레이어의 입력을 받아 현재 월드 상태와 종합하여 LLM에게 "다음 상황을 묘사하고 판정해줘"라는 프롬프트를 보냅니다.
- `characters.json`은 TRPG의 '캐릭터 시트'가 되며, 여기에 스탯, 스킬 등을 정의합니다.

---

## 결론

이 가이드는 AI Town의 정교한 아키텍처를 완전히 분석하고, 이를 기반으로 한 단계별 구현 방법을 제시합니다. 각 단계는 검증 가능한 결과물을 만들어내며, 점진적으로 더 복잡하고 생동감 있는 AI 시뮬레이션을 구축할 수 있도록 설계되었습니다.

개발 과정에서 막히거나 다음 단계에 대한 아이디어가 필요할 때 언제든 이 문서를 참고하여, 원하시는 멋진 AI 시뮬레이션을 완성하시기 바랍니다.main.js`**에서 '다음 턴 진행' 버튼 클릭 시 `engine.runStep(gameState)`를 호출하도록 연결합니다.

### Phase 2: AI의 첫 번째 숨결 (Agent Loop & Input System)

**목표:** AI Town의 AI 작동 방식인 **'에이전트 루프'**의 가장 기초적인 형태를 구현합니다. AI는 이제 세상을 관찰하고, 판단하며, 시스템에 '입력'을 제출하여 행동합니다.

**AI Town의 에이전트 루프:** AI는 매 스텝마다 **관찰/판단 (`Agent.tick`) → "생각" 시작 (`startOperation`) → 깊은 생각 (LLM 호출) → 행동 요청 (Input 제출) → 마무리**의 과정을 거칩니다. 이 단계에서는 '깊은 생각'을 제외한 루프의 뼈대를 만듭니다.

**구현 방법:**

1. **`agent.js`의 `tick(character, gameState)` 함수 (관찰 및 판단):**
   - **가장 먼저 할 일:** 진행 중인 작업(`character.inProgressOperation`)이 있는지 확인합니다. 있다면, 이번 턴에는 아무것도 하지 않고 기다립니다.
   - **판단:** 지금은 간단하게 `Math.random()`을 사용하여 '이동'할지 말지를 결정합니다.
   - **행동 요청 (Input 제출):** 이동하기로 결정했다면, AI는 `gameState`를 직접 수정하지 않습니다. 대신, **'입력' 객체**를 만들어 `gameState.inputs` 배열에 추가합니다.

```javascript
// in agent.tick()
const newLocationId = "library"; // 무작위로 선택
const moveInput = {
  type: 'moveTo',
  characterId: character.id,
  target: newLocationId
};
gameState.inputs.push(moveInput);
```

2. **`gameLogic.js`의 `movePlayer(gameState, input)` 함수 (대본의 규칙):**
   - `engine.js`가 이 함수를 호출하면, `input`의 정보를 바탕으로 실제 `gameState`의 `character.location`을 변경합니다.

### Phase 3: 대화와 비동기적 "생각" (Conversation & Asynchronous Operation)

**목표:** AI가 대화를 시작하게 하고, AI Town처럼 시간이 오래 걸리는 LLM 호출을 게임의 메인 흐름에 영향을 주지 않는 **비동기 작업**으로 처리하는 시스템을 구현합니다.

**AI Town의 비동기 처리:** LLM 호출처럼 시간이 오래 걸리는 작업은 `startOperation`을 통해 별도의 비동기 함수(`internalAction`)로 실행됩니다. 이를 통해 AI가 "생각"하는 동안에도 게임 세계는 멈추지 않고 흘러갑니다.

**구현 방법:**

1. **`agent.js`의 `tick()` 함수 수정:**
   - **관찰:** 현재 위치에 다른 캐릭터가 있는지 확인합니다.
   - **판단:** 대화할 상대가 있고, 대화 쿨다운이 지났다면 '대화 시작'을 결정합니다.
   - **"생각" 시작:** LLM을 직접 호출하는 대신, `character.inProgressOperation` 상태를 설정하고 `agent.startConversation(character, otherCharacter, gameState)`를 **비동기(`async`)**로 호출합니다.

```javascript
// in agent.tick()
character.inProgressOperation = { type: 'startConversation', targetId: otherChar.id };
agent.startConversation(character, otherChar, gameState); // await 없이 호출
```

2. **`